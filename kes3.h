/*****************************************************************************
 * kes3.h
 *
 * Class declarations for tableau KE-S3.
 *****************************************************************************/

#ifndef __KES3_H__
#define __KES3_H__

#include <map>
#include <set>
#include <string>
#include <vector>

#include "formula.h"
#include "ke.h"


//////////////////////////////////////////////////////////////////////////////
// Encapsulates the KES3 tableau default strategy. It:
// - Analyses all the alphas first, top down;
// - Then, tries to analyse the first beta, top down, with a literal as
//   secondary;
// - Then, applies the PB rule with a subformula of the first beta non
//   analysed with the properties:
//    1. must have value=* with respect to the valuation given by the literals
//       in the branch, and
//    2. for some atom A, must have an occurrence of A with the inverse
//       polarity of the literal where A occurs in the branch.
//////////////////////////////////////////////////////////////////////////////

class KES3Strategy : public KEPolarityStrategy
{
public:
  KES3Strategy();
  virtual ~KES3Strategy();

  void setTableau(Tableau *tableau) { tab = tableau; };

  virtual Formula *choosePB();

protected:
  Tableau *tab;
};


//////////////////////////////////////////////////////////////////////////////
// Encapsulates a KE tableau strategy that:
// - Analyses all the alphas first, top down, *EXCEPT* the A_E_NOT rule;
// - Then, tries to analyse the first beta, top down, with a literal as
//   secondary;
// - Then, applies the PB rule with a subformula of the first beta non
//   analysed with the properties:
//    1. must have value=* with respect to the valuation given by the literals
//       in the branch, and
//    2. for some atom A, must have an occurrence of A with the inverse
//       polarity of the literal where A occurs in the branch.
//    3. give preference to formulas containing less atoms outside S.
// - Then, applies the alpha rule A_E_NOT, giving preference to formulas
//   containing less atoms outside S.
//
//////////////////////////////////////////////////////////////////////////////

class KES3AENOTLastStrategy : public KES3Strategy
{
 public:
  KES3AENOTLastStrategy();
  virtual ~KES3AENOTLastStrategy();

  virtual bool hasApplicableSimpleAlpha();
  virtual bool hasApplicableAENOT();

  virtual unsigned int chooseAlpha();
  virtual Formula *choosePB();
  virtual int nextRule();
  
 protected:
  bool hasAppSimpleAlpha;
  bool hasAppAENOT;
  unsigned int indexAppAlpha;
};


//////////////////////////////////////////////////////////////////////////////
// Encapsulates a KE tableau.
//////////////////////////////////////////////////////////////////////////////

class KES3Tableau : public KETableau
{
  friend class KES3Strategy;
  friend class KES3AENOTLastStrategy;

 public:
  KES3Tableau(const string& id, SignedFormula *fml,
	      KES3Tableau *parent = NULL);
  KES3Tableau(const string& id, const vector<SignedFormula *>& fmls,
	      KES3Tableau *parent = NULL);
  ~KES3Tableau() { }

  virtual void setStrategy(KES3Strategy *strategy);

  virtual bool close();

  // Returns a string representation of the formula.
  string toString(int level=0) const;
  
  // Returns the current state of the context set S.
  set<string> S() const;

  // THIS SHOULD BE PROTECTED. It is being acessed in the call of the
  // constructor of the AENOTLast strategy. (Is this a case to use
  // friend classes?)

  // The context set of atoms
  // S.
  set<string> _S;

 protected:
  virtual bool applyRule(KETableau::enumRule r,
			 vector<SignedFormula *>& in,
			 vector<SignedFormula *>& out);

  // Performs pre-close operations.
  virtual void preClose();

  // Performs post-close operations.
  virtual void postClose();

  // Inserts the atoms of formula f into the context set _S
  void InsertAtoms(Formula *f);

  // Create a child tableau.
  virtual void createChild(const string& id, SignedFormula *fml);

  // Associates each index of formula (generated by the T_NOT alpha
  // rule) with the state of S generated by the rule.
  map<unsigned int, set<string> > mS;

 private:
  // The strategy object.
  KES3Strategy *_strategy;
};

#endif
